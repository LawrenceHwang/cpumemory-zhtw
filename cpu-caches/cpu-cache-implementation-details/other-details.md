# 3.3.5. 其它細節

到目前為止，我們已經討論過由三個部分 –– 標籤、集合索引、以及快取行偏移量 –– 組成的位址。但實際使用的位址是什麼呢？所有有關的處理器現今都是將虛擬定址空間提供給行程，這代表有二種不同的位址：虛擬的以及實體的。

虛擬記憶體的問題是，它們不是唯一的。虛擬記憶體能夠 –– 隨著時間 –– 指涉到不同的實體記憶體位址。在不同行程中的相同位址也可能會指涉到不同的實體位址。所以使用實體記憶體位址永遠比較好，對吧？

這裡的問題是，在執行期間使用的虛擬記憶體必須在記憶體管理單元（Memory Management Unit，MMU）的幫助下轉譯成實體位址。這是個不單純的操作。在執行一個指令的管線中，實體位址可能只有在之後的階段才能取得。這表示快取邏輯必須非常快速地判定這個記憶體位置是否被快取了。若是能夠使用虛擬位址，快取查詢就能夠早點在管線中進行，並且在快取命中的情況下，就能夠取得記憶體內容了。結果是，管線能夠隱藏更多記憶體存取的成本。

處理器設計者目前是使用虛擬位址來標記第一層級的快取。這些快取非常地小，而且清除也不會太費力。若是一個行程的分頁表樹（page table tree）改變了，至少必須局部地清理快取。假如處理器擁有能夠指定被改變的虛擬位址範圍的指令，就有可能避免一次完整的沖出。考慮到 L1i 與 L1d 快取的等待時間很短（~3 週期），使用虛擬位址幾乎是強迫性的。

對於大一點的快取，包含 L2、L3、... 快取，是需要實體位址標記的。這些快取有比較長的等待時間，而虛擬→實體位址轉譯能夠在時間內完成。因為這些快取比較大（即，當它們被沖出時，會損失大量的資訊），並且因為主記憶體存取的等待時間，重新填入它們會花上很久的時間，因此沖出它們的代價經常不小。

一般來說，應該沒必要知道在那些快取中的位址管理的細節。它們無法改變，而且所有會影響效能的因子通常是應該避免、或者是與高成本相關聯的東西。塞滿快取容量是很糟的，而且若是多數被使用的快取行都落在同一組集合中，所有快取都會很快地碰到問題。後者能夠以虛擬定址的快取來避免，但對於使用者層級的行程來說，要避免使用實體位址定址的快取是不可能的。或許唯一應該記住的細節是，可能的話，別在同個行程裡將同個實體記憶體位置映射到二個以上的虛擬位址。

另一個對程式開發者來說滿無趣的快取細節是快取的替換策略。大多快取會先逐出近期最少使用的（Least Recently Used，LRU）元素。以較大的關聯度（由於增加更多的處理器核，關聯度可能會在接下來幾年內進一步地增長）維持 LRU 清單會變得越來越昂貴，我們可能會看到被採用的不同策略。

至於快取的替換，一介程式開發者能做的不多。若是快取是使用實體位址的標籤，就沒有任何辦法能找出虛擬位址與快取集之間的關聯。所有邏輯分頁的快取行可能都映射到相同的快取集，留著大量的快取不用。如果是這樣的話，不讓這太常發生就是作業系統的工作了。

隨著虛擬化（virtualization）的出現，事情變得更加複雜。現在甚至不是作業系統擁有對實體記憶體指派的控制。而是虛擬機器監視器（Virtual Machine Monitor，VMM，又稱 Hypervisor）有指派實體記憶體的職責。

一介程式開發者能做的最多就是 a) 完全使用邏輯記憶體分頁 b) 使用盡可能大的分頁大小，以盡可能地多樣化實體位址。較大的分頁大小也有其它好處，但這是另一個主題（見第四節）。

